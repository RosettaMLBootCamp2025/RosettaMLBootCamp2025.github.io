<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2. Introduction to Structure Prediction – ML Protein Design Bootcamp 2025</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-b3b235ae6ba71d6e5c2a90c00144237d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- Shared Mol* component include for target pages -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pdbe-molstar@latest/build/pdbe-molstar-component.js"></script>
<style>
  .molstar-container {
    width: 100%;
    height: 500px;
    position: relative;
    margin-bottom: 20px;
    border: 1px solid #eee;
    border-radius: 8px;
    overflow: hidden;
  }
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">ML Protein Design Bootcamp 2025</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../monday/index.html"> 
<span class="menu-text">Monday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../tuesday/index.html" aria-current="page"> 
<span class="menu-text">Tuesday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../wednesday/index.html"> 
<span class="menu-text">Wednesday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../thursday/index.html"> 
<span class="menu-text">Thursday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capstone/index.html"> 
<span class="menu-text">Capstone</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/RosettaMLBootCamp2025/RosettaMLBootCamp2025.github.io/issues/new"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text">Report Issue</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../tuesday/2-structure-prediction.html">2. Introduction to Structure Prediction</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tuesday</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/1-pymol.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. PyMOL and Visual Studio Code</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/2-structure-prediction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">2. Introduction to Structure Prediction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/3-alphafold2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. AlphaFold2 and OpenFold</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/4-esmfold.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. ESMFold vs.&nbsp;AlphaFold2</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#slides" id="toc-slides" class="nav-link active" data-scroll-target="#slides">Slides</a></li>
  <li><a href="#what-is-structure-prediction" id="toc-what-is-structure-prediction" class="nav-link" data-scroll-target="#what-is-structure-prediction">What is Structure Prediction?</a></li>
  <li><a href="#the-theoretical-foundation" id="toc-the-theoretical-foundation" class="nav-link" data-scroll-target="#the-theoretical-foundation">The Theoretical Foundation</a>
  <ul class="collapse">
  <li><a href="#anfinsens-thermodynamic-hypothesis-1960s" id="toc-anfinsens-thermodynamic-hypothesis-1960s" class="nav-link" data-scroll-target="#anfinsens-thermodynamic-hypothesis-1960s">Anfinsen’s Thermodynamic Hypothesis (1960s)</a></li>
  <li><a href="#levinthals-paradox" id="toc-levinthals-paradox" class="nav-link" data-scroll-target="#levinthals-paradox">Levinthal’s Paradox</a></li>
  <li><a href="#the-folding-funnel" id="toc-the-folding-funnel" class="nav-link" data-scroll-target="#the-folding-funnel">The Folding Funnel</a></li>
  </ul></li>
  <li><a href="#a-brief-history-casp-and-the-road-to-alphafold" id="toc-a-brief-history-casp-and-the-road-to-alphafold" class="nav-link" data-scroll-target="#a-brief-history-casp-and-the-road-to-alphafold">A Brief History: CASP and the Road to AlphaFold</a>
  <ul class="collapse">
  <li><a href="#critical-assessment-of-protein-structure-prediction-casp" id="toc-critical-assessment-of-protein-structure-prediction-casp" class="nav-link" data-scroll-target="#critical-assessment-of-protein-structure-prediction-casp">Critical Assessment of protein Structure Prediction (CASP)</a></li>
  <li><a href="#the-pre-alphafold-era" id="toc-the-pre-alphafold-era" class="nav-link" data-scroll-target="#the-pre-alphafold-era">The Pre-AlphaFold Era</a></li>
  <li><a href="#the-alphafold2-revolution-2020" id="toc-the-alphafold2-revolution-2020" class="nav-link" data-scroll-target="#the-alphafold2-revolution-2020">The AlphaFold2 Revolution (2020)</a></li>
  </ul></li>
  <li><a href="#structure-prediction-metrics" id="toc-structure-prediction-metrics" class="nav-link" data-scroll-target="#structure-prediction-metrics">Structure Prediction Metrics</a>
  <ul class="collapse">
  <li><a href="#root-mean-squared-deviation-rmsd" id="toc-root-mean-squared-deviation-rmsd" class="nav-link" data-scroll-target="#root-mean-squared-deviation-rmsd">Root Mean Squared Deviation (RMSD)</a></li>
  <li><a href="#local-distance-difference-test-lddt" id="toc-local-distance-difference-test-lddt" class="nav-link" data-scroll-target="#local-distance-difference-test-lddt">Local Distance Difference Test (lDDT)</a></li>
  <li><a href="#global-distance-test-gdt" id="toc-global-distance-test-gdt" class="nav-link" data-scroll-target="#global-distance-test-gdt">Global Distance Test (GDT)</a></li>
  <li><a href="#template-modeling-score-tm-score" id="toc-template-modeling-score-tm-score" class="nav-link" data-scroll-target="#template-modeling-score-tm-score">Template Modeling Score (TM-score)</a></li>
  </ul></li>
  <li><a href="#applications-of-structure-prediction" id="toc-applications-of-structure-prediction" class="nav-link" data-scroll-target="#applications-of-structure-prediction">Applications of Structure Prediction</a>
  <ul class="collapse">
  <li><a href="#molecular-replacement-in-crystallography" id="toc-molecular-replacement-in-crystallography" class="nav-link" data-scroll-target="#molecular-replacement-in-crystallography">1. Molecular Replacement in Crystallography</a></li>
  <li><a href="#interpreting-experimental-results" id="toc-interpreting-experimental-results" class="nav-link" data-scroll-target="#interpreting-experimental-results">2. Interpreting Experimental Results</a></li>
  <li><a href="#functional-prediction-and-hypothesis-testing" id="toc-functional-prediction-and-hypothesis-testing" class="nav-link" data-scroll-target="#functional-prediction-and-hypothesis-testing">3. Functional Prediction and Hypothesis Testing</a></li>
  <li><a href="#starting-point-for-protein-engineering" id="toc-starting-point-for-protein-engineering" class="nav-link" data-scroll-target="#starting-point-for-protein-engineering">4. Starting Point for Protein Engineering</a></li>
  </ul></li>
  <li><a href="#the-modern-prediction-landscape" id="toc-the-modern-prediction-landscape" class="nav-link" data-scroll-target="#the-modern-prediction-landscape">The Modern Prediction Landscape</a>
  <ul class="collapse">
  <li><a href="#msa-based-methods-e.g.-alphafold2-openfold" id="toc-msa-based-methods-e.g.-alphafold2-openfold" class="nav-link" data-scroll-target="#msa-based-methods-e.g.-alphafold2-openfold">MSA-Based Methods (e.g., AlphaFold2, OpenFold)</a></li>
  <li><a href="#language-model-based-methods-e.g.-esmfold" id="toc-language-model-based-methods-e.g.-esmfold" class="nav-link" data-scroll-target="#language-model-based-methods-e.g.-esmfold">Language Model-Based Methods (e.g., ESMFold)</a></li>
  <li><a href="#next-generation-methods-e.g.-alphafold3-chai-1-boltz-2" id="toc-next-generation-methods-e.g.-alphafold3-chai-1-boltz-2" class="nav-link" data-scroll-target="#next-generation-methods-e.g.-alphafold3-chai-1-boltz-2">Next-Generation Methods (e.g., AlphaFold3, Chai-1, Boltz-2)</a></li>
  </ul></li>
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">Key Takeaways</a></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead">Looking Ahead</a></li>
  <li><a href="#hands-on-exercise" id="toc-hands-on-exercise" class="nav-link" data-scroll-target="#hands-on-exercise">Hands-On Exercise</a>
  <ul class="collapse">
  <li><a href="#part-1-explore-casp-results" id="toc-part-1-explore-casp-results" class="nav-link" data-scroll-target="#part-1-explore-casp-results">Part 1: Explore CASP Results</a></li>
  <li><a href="#part-2-metric-comparison-exercise" id="toc-part-2-metric-comparison-exercise" class="nav-link" data-scroll-target="#part-2-metric-comparison-exercise">Part 2: Metric Comparison Exercise</a></li>
  <li><a href="#part-3-discussion-questions" id="toc-part-3-discussion-questions" class="nav-link" data-scroll-target="#part-3-discussion-questions">Part 3: Discussion Questions</a></li>
  <li><a href="#part-4-prepare-for-alphafold2" id="toc-part-4-prepare-for-alphafold2" class="nav-link" data-scroll-target="#part-4-prepare-for-alphafold2">Part 4: Prepare for AlphaFold2</a></li>
  <li><a href="#reflection" id="toc-reflection" class="nav-link" data-scroll-target="#reflection">Reflection</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">2. Introduction to Structure Prediction</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This module provides the foundational concepts behind protein structure prediction—the theoretical framework that underlies tools like AlphaFold2, ESMFold, and other modern prediction methods.</p>
<section id="slides" class="level2">
<h2 class="anchored" data-anchor-id="slides">Slides</h2>
<iframe src="https://docs.google.com/presentation/d/1apTG2V__OjZyX2wLwHDN2o-EsMHgcBRG/embed?start=false&amp;loop=false&amp;delayms=3000" frameborder="0" width="100%" height="500" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
<hr>
</section>
<section id="what-is-structure-prediction" class="level2">
<h2 class="anchored" data-anchor-id="what-is-structure-prediction">What is Structure Prediction?</h2>
<p>At its core, protein structure prediction attempts to answer a deceptively simple question:</p>
<blockquote class="blockquote">
<p><strong>Given the linear amino acid sequence of a polypeptide, what is its 3D structure?</strong></p>
</blockquote>
<p>This is known as the <strong>protein folding problem</strong>, and it has been one of the grand challenges of molecular biology for over 50 years.</p>
<p><strong>Why is this hard?</strong></p>
<p>A protein sequence like:</p>
<pre><code>MGDIQVQVNIDDNGKNFDYTYTVTTESELQKVLNELMDYIKKQGAKRVRISITARTKKEAEKFAAILIKVFAELGYNDINVTFDGDTVTVEGQLE</code></pre>
<p>Must fold into a precise three-dimensional arrangement where: - Every atom has specific coordinates - The structure is thermodynamically stable - The fold enables biological function</p>
<hr>
</section>
<section id="the-theoretical-foundation" class="level2">
<h2 class="anchored" data-anchor-id="the-theoretical-foundation">The Theoretical Foundation</h2>
<section id="anfinsens-thermodynamic-hypothesis-1960s" class="level3">
<h3 class="anchored" data-anchor-id="anfinsens-thermodynamic-hypothesis-1960s">Anfinsen’s Thermodynamic Hypothesis (1960s)</h3>
<p>Christian Anfinsen’s Nobel Prize-winning work established a fundamental principle:</p>
<blockquote class="blockquote">
<p><strong>The native (functional) structure of a protein is at a free energy minimum.</strong></p>
</blockquote>
<p>This means: - The sequence contains all the information needed to specify the structure - Given the right conditions, a protein will spontaneously fold to its native state - Structure is determined by physics, not by cellular machinery</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Anfinsen’s Experiment
</div>
</div>
<div class="callout-body-container callout-body">
<p>Anfinsen showed that ribonuclease A, when completely unfolded (denatured), would spontaneously refold to its active form when denaturing conditions were removed. This proved that the amino acid sequence alone determines the final structure.</p>
</div>
</div>
</section>
<section id="levinthals-paradox" class="level3">
<h3 class="anchored" data-anchor-id="levinthals-paradox">Levinthal’s Paradox</h3>
<p>Shortly after Anfinsen’s work, Cyrus Levinthal raised a puzzling question:</p>
<blockquote class="blockquote">
<p><strong>How can proteins fold so quickly if they have so many possible conformations?</strong></p>
</blockquote>
<p>Consider a modest 101-residue protein: - Each residue has ~3 possible backbone conformations (φ/ψ angles) - Total possible conformations: <strong>3^200 ≈ 10^95 states</strong> - If the protein sampled one conformation per picosecond, it would take longer than the age of the universe to find the right one</p>
<p>Yet proteins fold in milliseconds to seconds. How?</p>
</section>
<section id="the-folding-funnel" class="level3">
<h3 class="anchored" data-anchor-id="the-folding-funnel">The Folding Funnel</h3>
<p>The resolution to Levinthal’s paradox came from understanding that the energy landscape is not flat—it’s shaped like a <strong>funnel</strong>:</p>
<pre><code>     ╱ ╲ ╱ ╲      ← High energy, many conformations (unfolded)
    ╱   ╲   ╲
   ╱     ╲   ╲
  ╱       ╲   ╲
 ╱    ↓    ╲   ╲   ← Energy decreases as structure forms
╱___________╲___╲
      ●          ← Native state (energy minimum)</code></pre>
<p><strong>Key insights:</strong></p>
<ol type="1">
<li><strong>Not a random search</strong>: The protein doesn’t sample all conformations—it follows an energetic gradient</li>
<li><strong>Local interactions guide folding</strong>: Secondary structure (helices, sheets) forms first, providing scaffolding</li>
<li><strong>Funnel shape</strong>: Many paths lead to the same native state</li>
<li><strong>Rugged landscape</strong>: In reality, there are local minima (kinetic traps) that can slow folding</li>
</ol>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Reality is More Complex
</div>
</div>
<div class="callout-body-container callout-body">
<p>In practice, the folding landscape isn’t one clean funnel—it’s many interconnected funnels. This creates: - <strong>Folding intermediates</strong>: Partially folded states - <strong>Kinetic traps</strong>: Local minima that delay folding - <strong>Multiple conformations</strong>: Some proteins sample several states - <strong>Intrinsically disordered regions</strong>: Parts that never fully fold</p>
<p>This complexity is what makes structure prediction so challenging!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="a-brief-history-casp-and-the-road-to-alphafold" class="level2">
<h2 class="anchored" data-anchor-id="a-brief-history-casp-and-the-road-to-alphafold">A Brief History: CASP and the Road to AlphaFold</h2>
<section id="critical-assessment-of-protein-structure-prediction-casp" class="level3">
<h3 class="anchored" data-anchor-id="critical-assessment-of-protein-structure-prediction-casp">Critical Assessment of protein Structure Prediction (CASP)</h3>
<p>CASP is a biennial competition that has tracked progress in structure prediction since 1994. Organizers release sequences of proteins whose structures have been solved but not yet published, and teams submit blind predictions.</p>
<p><strong>Key milestones:</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Year</th>
<th>CASP</th>
<th>Major Development</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1998</td>
<td>CASP3</td>
<td>Fragment-based assembly (Rosetta)</td>
</tr>
<tr class="even">
<td>2014</td>
<td>CASP11</td>
<td>Co-evolutionary analysis + deep learning</td>
</tr>
<tr class="odd">
<td>2018</td>
<td>CASP13</td>
<td>AlphaFold1: Deep learning-guided minimization</td>
</tr>
<tr class="even">
<td>2020</td>
<td>CASP14</td>
<td><strong>AlphaFold2</strong>: Near-experimental accuracy</td>
</tr>
<tr class="odd">
<td>2022</td>
<td>CASP15</td>
<td>AlphaFold-Multimer, ESMFold emerge</td>
</tr>
</tbody>
</table>
</section>
<section id="the-pre-alphafold-era" class="level3">
<h3 class="anchored" data-anchor-id="the-pre-alphafold-era">The Pre-AlphaFold Era</h3>
<p><strong>Fragment-based methods (Rosetta, ~1998):</strong> - Break known structures into fragments - Assemble fragments guided by energy functions - Sample many conformations, select lowest energy</p>
<p><strong>Co-evolutionary methods (~2014):</strong> - Key insight: Residues that contact each other in 3D co-evolve in sequence - Multiple sequence alignments (MSAs) reveal which residues co-vary - These “contact maps” constrain structure prediction</p>
<p><strong>Early deep learning (~2018):</strong> - Neural networks predict contact maps from MSAs - Use contacts to guide physics-based minimization - AlphaFold1 used this approach</p>
</section>
<section id="the-alphafold2-revolution-2020" class="level3">
<h3 class="anchored" data-anchor-id="the-alphafold2-revolution-2020">The AlphaFold2 Revolution (2020)</h3>
<p>AlphaFold2 achieved what many thought was decades away:</p>
<ul>
<li><strong>GDT scores of ~90</strong> on difficult targets (previously ~60 was state-of-the-art)</li>
<li><strong>Approaching experimental accuracy</strong> for many proteins</li>
<li><strong>End-to-end learning</strong>: Directly predicts coordinates, not intermediate features</li>
</ul>
<p>We’ll explore AlphaFold2’s architecture in detail in the next module.</p>
<hr>
</section>
</section>
<section id="structure-prediction-metrics" class="level2">
<h2 class="anchored" data-anchor-id="structure-prediction-metrics">Structure Prediction Metrics</h2>
<p>When evaluating predictions, several metrics are used:</p>
<section id="root-mean-squared-deviation-rmsd" class="level3">
<h3 class="anchored" data-anchor-id="root-mean-squared-deviation-rmsd">Root Mean Squared Deviation (RMSD)</h3>
<p><strong>What it measures:</strong> Average distance between corresponding atoms after optimal superposition.</p>
<p><span class="math display">\[RMSD = \sqrt{\frac{1}{N}\sum_{i=1}^{N}d_i^2}\]</span></p>
<p>where <span class="math inline">\(d_i\)</span> is the distance between atom <span class="math inline">\(i\)</span> in the prediction and reference.</p>
<p><strong>Interpretation:</strong> - &lt; 2 Å: Excellent (atomic-level accuracy) - 2-4 Å: Good (correct fold, minor deviations) - 4-8 Å: Moderate (correct topology, some errors) - &gt; 8 Å: Poor (likely wrong fold)</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Warning</span>RMSD Limitations
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><strong>Length-dependent</strong>: Longer proteins tend to have higher RMSD</li>
<li><strong>Sensitive to outliers</strong>: One badly placed domain can dominate</li>
<li><strong>Requires superposition</strong>: Choice of alignment region matters</li>
</ul>
</div>
</div>
</section>
<section id="local-distance-difference-test-lddt" class="level3">
<h3 class="anchored" data-anchor-id="local-distance-difference-test-lddt">Local Distance Difference Test (lDDT)</h3>
<p><strong>What it measures:</strong> Local structural similarity without superposition.</p>
<p>For each residue, lDDT asks: “Are the distances to neighboring residues preserved?”</p>
<p><strong>Key properties:</strong> - <strong>Range</strong>: 0 to 1 (or 0-100 as percentage) - <strong>Length-independent</strong>: Can compare proteins of different sizes - <strong>Per-residue</strong>: Identifies which regions are well-predicted</p>
<p><strong>This is the metric used for pLDDT (predicted lDDT) in AlphaFold2!</strong></p>
</section>
<section id="global-distance-test-gdt" class="level3">
<h3 class="anchored" data-anchor-id="global-distance-test-gdt">Global Distance Test (GDT)</h3>
<p><strong>What it measures:</strong> Fraction of residues within various distance thresholds.</p>
<p><span class="math display">\[GDT_{TS} = \frac{1}{4}(P_1 + P_2 + P_4 + P_8)\]</span></p>
<p>where <span class="math inline">\(P_x\)</span> is the percentage of residues within <span class="math inline">\(x\)</span> Å of the reference.</p>
<p><strong>Interpretation:</strong> - &gt; 90: Excellent - 70-90: Good - 50-70: Moderate - &lt; 50: Poor</p>
<p><strong>GDT-TS was the primary metric in CASP until AlphaFold2 essentially “solved” it.</strong></p>
</section>
<section id="template-modeling-score-tm-score" class="level3">
<h3 class="anchored" data-anchor-id="template-modeling-score-tm-score">Template Modeling Score (TM-score)</h3>
<p><strong>What it measures:</strong> Global structural similarity, normalized by protein length.</p>
<p><strong>Key properties:</strong> - <strong>Range</strong>: 0 to 1 - <strong>Length-independent</strong>: Enables comparison across protein sizes - <strong>Threshold</strong>: TM-score &gt; 0.5 generally indicates same fold</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>TM-score</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt; 0.5</td>
<td>Same fold</td>
</tr>
<tr class="even">
<td>0.3-0.5</td>
<td>Possibly related</td>
</tr>
<tr class="odd">
<td>&lt; 0.3</td>
<td>Likely different folds</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="applications-of-structure-prediction" class="level2">
<h2 class="anchored" data-anchor-id="applications-of-structure-prediction">Applications of Structure Prediction</h2>
<section id="molecular-replacement-in-crystallography" class="level3">
<h3 class="anchored" data-anchor-id="molecular-replacement-in-crystallography">1. Molecular Replacement in Crystallography</h3>
<p><strong>Problem:</strong> X-ray crystallography requires initial “phases” to solve structures.</p>
<p><strong>Solution:</strong> Predicted structures can provide starting models for: - Phase determination - Completing partial experimental structures - Filling in loops or disordered regions</p>
</section>
<section id="interpreting-experimental-results" class="level3">
<h3 class="anchored" data-anchor-id="interpreting-experimental-results">2. Interpreting Experimental Results</h3>
<p><strong>Example scenarios:</strong> - A mutation causes loss of function—why? The structure shows it’s in the active site. - A protein doesn’t express well—the structure reveals aggregation-prone regions. - Two proteins interact—structures suggest the binding interface.</p>
</section>
<section id="functional-prediction-and-hypothesis-testing" class="level3">
<h3 class="anchored" data-anchor-id="functional-prediction-and-hypothesis-testing">3. Functional Prediction and Hypothesis Testing</h3>
<p><strong>From structure, you can infer:</strong> - Active site location and chemistry - Binding pocket characteristics - Likely interaction partners (from shape complementarity) - Potential allosteric sites</p>
</section>
<section id="starting-point-for-protein-engineering" class="level3">
<h3 class="anchored" data-anchor-id="starting-point-for-protein-engineering">4. Starting Point for Protein Engineering</h3>
<p><strong>Critical for:</strong> - <strong>Rational design</strong>: Knowing where to put mutations - <strong>Directed evolution</strong>: Understanding which regions to diversify - <strong>De novo design</strong>: Validating whether designed sequences will fold</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Structure Prediction in Your Research
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this bootcamp, you’ll use structure prediction to:</p>
<ol type="1">
<li><strong>Predict structures</strong> of proteins of interest</li>
<li><strong>Validate designs</strong> from tools like RFdiffusion</li>
<li><strong>Assess confidence</strong> to know which regions to trust</li>
<li><strong>Compare predictions</strong> from different methods</li>
</ol>
</div>
</div>
<hr>
</section>
</section>
<section id="the-modern-prediction-landscape" class="level2">
<h2 class="anchored" data-anchor-id="the-modern-prediction-landscape">The Modern Prediction Landscape</h2>
<p>Today’s structure prediction tools fall into two main categories:</p>
<section id="msa-based-methods-e.g.-alphafold2-openfold" class="level3">
<h3 class="anchored" data-anchor-id="msa-based-methods-e.g.-alphafold2-openfold">MSA-Based Methods (e.g., AlphaFold2, OpenFold)</h3>
<p><strong>Strengths:</strong> - Highest accuracy for proteins with many homologs - Leverage evolutionary information - Multiple model ensemble provides uncertainty estimates</p>
<p><strong>Limitations:</strong> - Slower (MSA generation takes time) - Less accurate for orphan proteins (few homologs) - Computationally expensive</p>
</section>
<section id="language-model-based-methods-e.g.-esmfold" class="level3">
<h3 class="anchored" data-anchor-id="language-model-based-methods-e.g.-esmfold">Language Model-Based Methods (e.g., ESMFold)</h3>
<p><strong>Strengths:</strong> - Very fast (no MSA needed) - Work on designed/synthetic proteins - Simpler pipeline</p>
<p><strong>Limitations:</strong> - Generally lower accuracy than MSA-based methods - No ensemble diversity from single prediction - May miss evolutionary insights</p>
</section>
<section id="next-generation-methods-e.g.-alphafold3-chai-1-boltz-2" class="level3">
<h3 class="anchored" data-anchor-id="next-generation-methods-e.g.-alphafold3-chai-1-boltz-2">Next-Generation Methods (e.g., AlphaFold3, Chai-1, Boltz-2)</h3>
<p>The field is rapidly advancing with: - <strong>Multi-modal predictions</strong>: Proteins + ligands + nucleic acids - <strong>Diffusion-based approaches</strong>: New generative paradigms - <strong>Improved confidence estimation</strong>: Better uncertainty quantification</p>
<hr>
</section>
</section>
<section id="key-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h2>
<ol type="1">
<li><strong>Anfinsen’s hypothesis</strong> established that sequence determines structure</li>
<li><strong>Levinthal’s paradox</strong> highlighted the computational challenge</li>
<li><strong>The folding funnel</strong> explains how proteins fold efficiently</li>
<li><strong>CASP</strong> has tracked 25+ years of progress</li>
<li><strong>AlphaFold2</strong> achieved a major breakthrough in 2020</li>
<li><strong>Multiple metrics</strong> (RMSD, lDDT, GDT, TM-score) capture different aspects of accuracy</li>
<li><strong>Structure enables function</strong>: Predictions have many practical applications</li>
</ol>
<hr>
</section>
<section id="looking-ahead" class="level2">
<h2 class="anchored" data-anchor-id="looking-ahead">Looking Ahead</h2>
<p>In the next modules, you’ll:</p>
<ol type="1">
<li><strong>Learn AlphaFold2’s architecture</strong> and how it achieves high accuracy</li>
<li><strong>Run your own predictions</strong> using ColabFold/LocalColabFold</li>
<li><strong>Compare methods</strong> (AlphaFold2 vs ESMFold) to understand trade-offs</li>
<li><strong>Visualize confidence</strong> and interpret prediction quality</li>
</ol>
<p>Understanding these foundational concepts will help you use structure prediction tools effectively and interpret their outputs critically.</p>
<hr>
</section>
<section id="hands-on-exercise" class="level2">
<h2 class="anchored" data-anchor-id="hands-on-exercise">Hands-On Exercise</h2>
<p>This module is primarily conceptual, but let’s reinforce these ideas with some exploration.</p>
<section id="part-1-explore-casp-results" class="level3">
<h3 class="anchored" data-anchor-id="part-1-explore-casp-results">Part 1: Explore CASP Results</h3>
<p><strong>Goal:</strong> Understand how the field has progressed by looking at real CASP data.</p>
<ol type="1">
<li><p><strong>Visit the CASP website:</strong> <a href="https://predictioncenter.org">predictioncenter.org</a></p></li>
<li><p><strong>Compare CASP rounds:</strong></p>
<ul>
<li>Look at results from CASP11 (2014) vs CASP14 (2020)</li>
<li>Find the GDT-TS scores for the top predictors</li>
<li>Notice how dramatically scores improved with AlphaFold2</li>
</ul></li>
<li><p><strong>Questions to consider:</strong></p>
<ul>
<li>What was the typical GDT-TS for “hard” targets before AlphaFold2?</li>
<li>How did AlphaFold2’s scores compare to the rest of the field in CASP14?</li>
<li>Why do you think some targets are labeled “hard” vs “easy”?</li>
</ul></li>
</ol>
</section>
<section id="part-2-metric-comparison-exercise" class="level3">
<h3 class="anchored" data-anchor-id="part-2-metric-comparison-exercise">Part 2: Metric Comparison Exercise</h3>
<p><strong>Goal:</strong> Develop intuition for different structure comparison metrics.</p>
<p>Using PyMOL, let’s compare two related structures:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch two related kinase structures</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>fetch <span class="dv">1</span><span class="er">ATP</span>   <span class="co"># PKA with ATP bound</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>fetch <span class="ot">1J</span><span class="er">3H</span>   <span class="co"># PKA in different conformation</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Align them</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>align <span class="ot">1J</span><span class="er">3H</span>, <span class="dv">1</span><span class="er">ATP</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Note the RMSD printed in the console</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Now think about:</strong></p>
<ol type="1">
<li><p><strong>RMSD question:</strong> The RMSD might be 2-4 Å. Does this mean the structures are different, or is this expected variation?</p></li>
<li><p><strong>Per-residue analysis:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Color by RMSD per residue (after alignment)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Red = high deviation, blue = low</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Which regions show the most difference? (Usually loops and termini)</p></li>
<li><p><strong>Why lDDT matters:</strong> If one domain moves relative to another (like in a kinase), RMSD after superposition will be high, but lDDT for each domain individually would still be good. This is why AlphaFold2 uses pLDDT as its confidence metric.</p></li>
</ol>
</section>
<section id="part-3-discussion-questions" class="level3">
<h3 class="anchored" data-anchor-id="part-3-discussion-questions">Part 3: Discussion Questions</h3>
<p>Work through these questions with a partner or write brief notes:</p>
<ol type="1">
<li><strong>Anfinsen’s hypothesis:</strong>
<ul>
<li>What evidence supports the idea that sequence determines structure?</li>
<li>Can you think of exceptions? (Hint: chaperones, prions, intrinsically disordered proteins)</li>
</ul></li>
<li><strong>Levinthal’s paradox:</strong>
<ul>
<li>If a protein has 100 residues and samples conformations at 10^12 per second, how long would it take to sample all 3^200 conformations?</li>
<li>Why doesn’t this happen in reality?</li>
</ul></li>
<li><strong>Practical implications:</strong>
<ul>
<li>You predict a structure with AlphaFold2 and get average pLDDT of 75. What does this mean?</li>
<li>One region has pLDDT &lt; 50. Should you trust it? What might it indicate biologically?</li>
</ul></li>
<li><strong>Choosing metrics:</strong>
<ul>
<li>You’re comparing two predictions of the same protein. When would you use RMSD vs TM-score?</li>
<li>Why is GDT-TS preferred over raw RMSD in CASP?</li>
</ul></li>
</ol>
</section>
<section id="part-4-prepare-for-alphafold2" class="level3">
<h3 class="anchored" data-anchor-id="part-4-prepare-for-alphafold2">Part 4: Prepare for AlphaFold2</h3>
<p>To get ready for the next module:</p>
<ol type="1">
<li><strong>Review your HPC access:</strong> Make sure you can log into your cluster</li>
<li><strong>Check for GPU availability:</strong> Run <code>nvidia-smi</code> on a GPU node</li>
<li><strong>Prepare a test sequence:</strong> Find the FASTA sequence for a protein you’re interested in</li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Sequence Resources
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><strong>UniProt:</strong> <a href="https://uniprot.org">uniprot.org</a> - Search for proteins and download sequences</li>
<li><strong>RCSB PDB:</strong> <a href="https://rcsb.org">rcsb.org</a> - Get sequences for proteins with known structures</li>
</ul>
</div>
</div>
</section>
<section id="reflection" class="level3">
<h3 class="anchored" data-anchor-id="reflection">Reflection</h3>
<p>After this module, you should be able to:</p>
<ul class="task-list">
<li><label><input type="checkbox">Explain Anfinsen’s thermodynamic hypothesis in your own words</label></li>
<li><label><input type="checkbox">Describe Levinthal’s paradox and how the folding funnel resolves it</label></li>
<li><label><input type="checkbox">List the major milestones in CASP history</label></li>
<li><label><input type="checkbox">Compare and contrast RMSD, lDDT, GDT, and TM-score</label></li>
<li><label><input type="checkbox">Explain when you would use structure prediction in your research</label></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script>
(function() {
  const STORAGE_KEY = 'bootcamp2025_progress';
  const LAST_PAGE_KEY = 'bootcamp2025_lastpage';

  // Get current page path
  const currentPath = window.location.pathname;
  const isHomePage = currentPath === '/' || currentPath.endsWith('/index.html') || currentPath === '/index.html' || currentPath.match(/^\/[^\/]*\/?$/);

  // Extract day from path
  function getDayFromPath(path) {
    const dayMap = {
      'monday': 'Monday',
      'tuesday': 'Tuesday',
      'wednesday': 'Wednesday',
      'thursday': 'Thursday',
      'capstone': 'Capstone'
    };
    const match = path.match(/\/(monday|tuesday|wednesday|thursday|capstone)\//i);
    return match ? dayMap[match[1].toLowerCase()] : null;
  }

  // Save current page as last visited (except homepage)
  if (!isHomePage) {
    const pageTitle = document.title.replace(' - ML Protein Design Bootcamp 2025', '');
    const day = getDayFromPath(currentPath);
    localStorage.setItem(LAST_PAGE_KEY, JSON.stringify({
      path: currentPath,
      title: pageTitle,
      day: day,
      timestamp: Date.now()
    }));
  }

  // Load progress data
  function getProgress() {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : { completed: [] };
  }

  // Save progress data
  function saveProgress(progress) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  }

  // Update progress bar on homepage
  function updateProgressBar() {
    const progress = getProgress();
    const totalModules = document.querySelectorAll('.module-checkbox').length ||
                         parseInt(document.body.dataset.totalModules) || 8; // fallback
    const completed = progress.completed.length;
    const percent = Math.round((completed / totalModules) * 100);

    const bar = document.getElementById('progress-bar');
    const count = document.getElementById('completed-count');

    if (bar) {
      bar.style.width = percent + '%';
      bar.textContent = percent + '%';
      bar.setAttribute('aria-valuenow', percent);
    }
    if (count) {
      count.textContent = completed;
    }
  }

  // Show resume banner on homepage if there's a saved page
  function showResumeBanner() {
    const lastPage = localStorage.getItem(LAST_PAGE_KEY);
    if (lastPage && isHomePage) {
      const data = JSON.parse(lastPage);
      const banner = document.getElementById('resume-banner');
      const link = document.getElementById('resume-link');
      const title = document.getElementById('last-page-title');

      if (banner && link && title && data.path) {
        // Format title with day prefix if available
        const displayTitle = data.day ? `${data.day}: ${data.title}` : data.title;
        title.textContent = displayTitle;
        link.href = data.path;
        banner.style.display = 'block';
      }
    }
  }

  // Initialize checkboxes on module pages
  function initCheckboxes() {
    const checkboxes = document.querySelectorAll('.module-checkbox');
    const progress = getProgress();

    checkboxes.forEach(cb => {
      const id = cb.dataset.moduleId;

      // Restore state
      if (progress.completed.includes(id)) {
        cb.checked = true;
      }

      // Save on change
      cb.addEventListener('change', function() {
        const progress = getProgress();
        if (this.checked) {
          if (!progress.completed.includes(id)) {
            progress.completed.push(id);
          }
        } else {
          progress.completed = progress.completed.filter(x => x !== id);
        }
        saveProgress(progress);
        updateProgressBar();
      });
    });
  }

  // Clear all progress
  window.clearProgress = function() {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(LAST_PAGE_KEY);
    location.reload();
  };

  // Mark all checkboxes on current page as complete
  window.markAllComplete = function() {
    const checkboxes = document.querySelectorAll('.module-checkbox');
    const progress = getProgress();

    checkboxes.forEach(cb => {
      const id = cb.dataset.moduleId;
      cb.checked = true;
      if (!progress.completed.includes(id)) {
        progress.completed.push(id);
      }
    });

    saveProgress(progress);
    updateProgressBar();
  };

  // Add "Mark all as complete" button to pages with checkboxes
  function addMarkAllButton() {
    const checkboxes = document.querySelectorAll('.module-checkbox');
    if (checkboxes.length > 0 && !isHomePage) {
      // Find the title element and add button after it
      const title = document.querySelector('h1.title, .quarto-title h1');
      if (title) {
        const btn = document.createElement('button');
        btn.textContent = 'Mark all as complete';
        btn.className = 'btn btn-outline-success btn-sm mark-all-btn';
        btn.style.cssText = 'margin-top: 0.5rem; margin-bottom: 1rem;';
        btn.onclick = window.markAllComplete;
        title.insertAdjacentElement('afterend', btn);
      }
    }
  }

  // Run on page load
  document.addEventListener('DOMContentLoaded', function() {
    showResumeBanner();
    initCheckboxes();
    updateProgressBar();
    addMarkAllButton();
  });
})();
</script>
<style>
.quiz-container {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 1.5rem;
  margin: 2rem 0;
  background-color: #f8f9fa;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.quiz-header {
  font-weight: 600;
  color: #495057;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.quiz-header i {
  color: #0d6efd;
}

.quiz-question {
  font-size: 1.1rem;
  margin-bottom: 1rem;
  font-weight: 500;
}

.quiz-options {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.quiz-option {
  padding: 0.75rem 1rem;
  border: 1px solid #dee2e6;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  background-color: white;
}

.quiz-option:hover {
  background-color: #e9ecef;
  border-color: #adb5bd;
}

.quiz-option.selected {
  background-color: #e7f1ff;
  border-color: #0d6efd;
  color: #0d6efd;
}

.quiz-option.correct {
  background-color: #d1e7dd;
  border-color: #198754;
  color: #0f5132;
}

.quiz-option.incorrect {
  background-color: #f8d7da;
  border-color: #dc3545;
  color: #842029;
}

.quiz-feedback {
  margin-top: 1rem;
  padding: 0.75rem;
  border-radius: 6px;
  display: none;
  font-size: 0.95rem;
}

.quiz-feedback.correct {
  background-color: #d1e7dd;
  color: #0f5132;
  display: block;
}

.quiz-feedback.incorrect {
  background-color: #f8d7da;
  color: #842029;
  display: block;
}

.check-btn {
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background-color: #0d6efd;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
}

.check-btn:hover {
  background-color: #0b5ed7;
}

.check-btn:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const quizzes = document.querySelectorAll('.quiz-container');

  quizzes.forEach(quiz => {
    const options = quiz.querySelectorAll('.quiz-option');
    const checkBtn = quiz.querySelector('.check-btn');
    const feedback = quiz.querySelector('.quiz-feedback');
    const correctIndex = parseInt(quiz.dataset.correctIndex);
    let selectedIndex = -1;

    options.forEach((option, index) => {
      option.addEventListener('click', () => {
        if (checkBtn.disabled) return; // Already answered
        
        options.forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');
        selectedIndex = index;
      });
    });

    checkBtn.addEventListener('click', () => {
      if (selectedIndex === -1) return;

      // Disable interaction
      checkBtn.disabled = true;
      checkBtn.textContent = 'Submitted';
      
      const selectedOption = options[selectedIndex];
      const correctOption = options[correctIndex];

      if (selectedIndex === correctIndex) {
        selectedOption.classList.add('correct');
        selectedOption.classList.remove('selected');
        feedback.textContent = quiz.dataset.correctFeedback || "Correct! Great job.";
        feedback.className = 'quiz-feedback correct';
      } else {
        selectedOption.classList.add('incorrect');
        selectedOption.classList.remove('selected');
        correctOption.classList.add('correct'); // Show the right answer
        feedback.textContent = quiz.dataset.incorrectFeedback || "Not quite. The correct answer is highlighted.";
        feedback.className = 'quiz-feedback incorrect';
      }
    });
  });
});
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>