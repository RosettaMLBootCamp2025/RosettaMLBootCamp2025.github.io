<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4. ESMFold vs.&nbsp;AlphaFold2 – ML Protein Design Bootcamp 2025</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-635a35c16803d16fd9db22f392043487.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- Shared Mol* component include for target pages -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pdbe-molstar@latest/build/pdbe-molstar-component.js"></script>
<style>
  .molstar-container {
    width: 100%;
    height: 500px;
    position: relative;
    margin-bottom: 20px;
    border: 1px solid #eee;
    border-radius: 8px;
    overflow: hidden;
  }
</style>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">ML Protein Design Bootcamp 2025</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../monday/index.html"> 
<span class="menu-text">Monday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../tuesday/index.html" aria-current="page"> 
<span class="menu-text">Tuesday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../wednesday/index.html"> 
<span class="menu-text">Wednesday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../thursday/index.html"> 
<span class="menu-text">Thursday</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capstone/index.html"> 
<span class="menu-text">Capstone</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/RosettaMLBootCamp2025/RosettaMLBootCamp2025.github.io/issues/new"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text">Report Issue</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../tuesday/4-esmfold.html">4. ESMFold vs.&nbsp;AlphaFold2</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tuesday</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/1-pymol.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. PyMOL and Visual Studio Code</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/2-structure-prediction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Introduction to Structure Prediction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/3-alphafold2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. AlphaFold2 and OpenFold</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tuesday/4-esmfold.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">4. ESMFold vs.&nbsp;AlphaFold2</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#learning-objectives" id="toc-learning-objectives" class="nav-link" data-scroll-target="#learning-objectives">Learning Objectives</a></li>
  <li><a href="#hands-on-exercise" id="toc-hands-on-exercise" class="nav-link" data-scroll-target="#hands-on-exercise">Hands-On Exercise</a>
  <ul class="collapse">
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">Setup</a></li>
  <li><a href="#part-1-running-esmfold-structure-prediction" id="toc-part-1-running-esmfold-structure-prediction" class="nav-link" data-scroll-target="#part-1-running-esmfold-structure-prediction">Part 1: Running ESMFold Structure Prediction</a></li>
  <li><a href="#quick-introduction-to-esmfold" id="toc-quick-introduction-to-esmfold" class="nav-link" data-scroll-target="#quick-introduction-to-esmfold">1.1 Quick Introduction to ESMFold</a></li>
  <li><a href="#write-your-esmfold-prediction-script" id="toc-write-your-esmfold-prediction-script" class="nav-link" data-scroll-target="#write-your-esmfold-prediction-script">1.2 Write Your ESMFold Prediction Script</a></li>
  <li><a href="#run-your-first-prediction" id="toc-run-your-first-prediction" class="nav-link" data-scroll-target="#run-your-first-prediction">1.3 Run Your First Prediction</a></li>
  </ul></li>
  <li><a href="#part-2-extracting-and-comparing-confidence-scores" id="toc-part-2-extracting-and-comparing-confidence-scores" class="nav-link" data-scroll-target="#part-2-extracting-and-comparing-confidence-scores">Part 2: Extracting and Comparing Confidence Scores</a>
  <ul class="collapse">
  <li><a href="#understanding-plddt-storage-in-pdb-files" id="toc-understanding-plddt-storage-in-pdb-files" class="nav-link" data-scroll-target="#understanding-plddt-storage-in-pdb-files">2.1 Understanding pLDDT Storage in PDB Files</a></li>
  <li><a href="#extract-plddt-scores" id="toc-extract-plddt-scores" class="nav-link" data-scroll-target="#extract-plddt-scores">2.2 Extract pLDDT Scores</a></li>
  <li><a href="#visualize-confidence-scores-in-pymol" id="toc-visualize-confidence-scores-in-pymol" class="nav-link" data-scroll-target="#visualize-confidence-scores-in-pymol">2.3 Visualize Confidence Scores in PyMOL</a></li>
  </ul></li>
  <li><a href="#part-3-direct-comparison---esmfold-vs-alphafold2" id="toc-part-3-direct-comparison---esmfold-vs-alphafold2" class="nav-link" data-scroll-target="#part-3-direct-comparison---esmfold-vs-alphafold2">Part 3: Direct Comparison - ESMFold vs AlphaFold2</a>
  <ul class="collapse">
  <li><a href="#prepare-for-comparison" id="toc-prepare-for-comparison" class="nav-link" data-scroll-target="#prepare-for-comparison">3.1 Prepare for Comparison</a></li>
  <li><a href="#visual-comparison-in-pymol" id="toc-visual-comparison-in-pymol" class="nav-link" data-scroll-target="#visual-comparison-in-pymol">3.2 Visual Comparison in PyMOL</a></li>
  <li><a href="#calculate-rmsd" id="toc-calculate-rmsd" class="nav-link" data-scroll-target="#calculate-rmsd">3.3 Calculate RMSD</a></li>
  </ul></li>
  <li><a href="#part-4-exploring-esmfold-features-optional---if-youre-ahead" id="toc-part-4-exploring-esmfold-features-optional---if-youre-ahead" class="nav-link" data-scroll-target="#part-4-exploring-esmfold-features-optional---if-youre-ahead">Part 4: Exploring ESMFold Features ⭐ OPTIONAL - If You’re Ahead</a>
  <ul class="collapse">
  <li><a href="#memory-optimization-with-chunking" id="toc-memory-optimization-with-chunking" class="nav-link" data-scroll-target="#memory-optimization-with-chunking">4.1 Memory Optimization with Chunking</a></li>
  <li><a href="#understanding-model-determinism" id="toc-understanding-model-determinism" class="nav-link" data-scroll-target="#understanding-model-determinism">4.2 Understanding Model Determinism</a></li>
  </ul></li>
  <li><a href="#part-5-speed-comparison---esmfold-vs-alphafold2" id="toc-part-5-speed-comparison---esmfold-vs-alphafold2" class="nav-link" data-scroll-target="#part-5-speed-comparison---esmfold-vs-alphafold2">Part 5: Speed Comparison - ESMFold vs AlphaFold2</a>
  <ul class="collapse">
  <li><a href="#compare-prediction-times" id="toc-compare-prediction-times" class="nav-link" data-scroll-target="#compare-prediction-times">5.1 Compare Prediction Times</a></li>
  <li><a href="#when-does-speed-matter" id="toc-when-does-speed-matter" class="nav-link" data-scroll-target="#when-does-speed-matter">5.2 When Does Speed Matter?</a></li>
  </ul></li>
  <li><a href="#part-6-choosing-the-right-model-for-your-research" id="toc-part-6-choosing-the-right-model-for-your-research" class="nav-link" data-scroll-target="#part-6-choosing-the-right-model-for-your-research">Part 6: Choosing the Right Model for Your Research</a>
  <ul class="collapse">
  <li><a href="#key-differences-summary" id="toc-key-differences-summary" class="nav-link" data-scroll-target="#key-differences-summary">6.1 Key Differences Summary</a></li>
  <li><a href="#decision-guide" id="toc-decision-guide" class="nav-link" data-scroll-target="#decision-guide">6.2 Decision Guide</a></li>
  <li><a href="#practical-scenarios---test-your-understanding" id="toc-practical-scenarios---test-your-understanding" class="nav-link" data-scroll-target="#practical-scenarios---test-your-understanding">6.3 Practical Scenarios - Test Your Understanding</a></li>
  <li><a href="#what-if-the-models-disagree" id="toc-what-if-the-models-disagree" class="nav-link" data-scroll-target="#what-if-the-models-disagree">6.4 What If the Models Disagree?</a></li>
  </ul></li>
  <li><a href="#part-7-key-takeaways-best-practices" id="toc-part-7-key-takeaways-best-practices" class="nav-link" data-scroll-target="#part-7-key-takeaways-best-practices">Part 7: Key Takeaways &amp; Best Practices</a>
  <ul class="collapse">
  <li><a href="#what-youve-learned" id="toc-what-youve-learned" class="nav-link" data-scroll-target="#what-youve-learned">7.1 What You’ve Learned</a></li>
  <li><a href="#best-practices-for-structure-prediction" id="toc-best-practices-for-structure-prediction" class="nav-link" data-scroll-target="#best-practices-for-structure-prediction">7.2 Best Practices for Structure Prediction</a></li>
  <li><a href="#recommended-workflow-for-most-projects" id="toc-recommended-workflow-for-most-projects" class="nav-link" data-scroll-target="#recommended-workflow-for-most-projects">7.3 Recommended Workflow for Most Projects</a></li>
  </ul></li>
  <li><a href="#additional-resources" id="toc-additional-resources" class="nav-link" data-scroll-target="#additional-resources">Additional Resources</a>
  <ul class="collapse">
  <li><a href="#documentation" id="toc-documentation" class="nav-link" data-scroll-target="#documentation">Documentation</a></li>
  <li><a href="#online-resources" id="toc-online-resources" class="nav-link" data-scroll-target="#online-resources">Online Resources</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">4. ESMFold vs.&nbsp;AlphaFold2</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In this module, you will use <strong>ESMFold</strong> to predict protein structures and systematically compare results with the <strong>AlphaFold2</strong> predictions you generated in the previous module. ESMFold uses a fundamentally different approach—a protein language model trained on sequences alone, without requiring Multiple Sequence Alignments (MSAs) or templates. By comparing ESMFold to AF2, you will understand the trade-offs between different prediction methods and learn when to use each approach.</p>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>ESMFold represents a different philosophy from AlphaFold2. While AF2 leverages evolutionary information through MSAs, ESMFold is built on a <strong>protein language model</strong> (ESM-2) that learns patterns directly from millions of protein sequences. This makes it:</p>
<ul>
<li><strong>Much faster</strong>: No MSA generation step</li>
<li><strong>Better for orphan proteins</strong>: Works without homologs</li>
<li><strong>Simpler pipeline</strong>: Sequence in, structure out</li>
</ul>
<p>But there are trade-offs—ESMFold may miss evolutionary insights that help AF2 achieve higher accuracy on well-studied proteins.</p>
</section>
<section id="learning-objectives" class="level2">
<h2 class="anchored" data-anchor-id="learning-objectives">Learning Objectives</h2>
<ol type="1">
<li><strong>Understand ESMFold’s language model approach</strong> vs AF2’s MSA-based approach</li>
<li><strong>Write Python code</strong> to use ESMFold following official documentation</li>
<li><strong>Compare prediction quality, speed, and confidence</strong> across different models</li>
<li><strong>Make informed decisions</strong> about model selection for different use cases</li>
<li><strong>Critically evaluate</strong> strengths and limitations of different prediction methods</li>
</ol>
<hr>
</section>
<section id="hands-on-exercise" class="level2">
<h2 class="anchored" data-anchor-id="hands-on-exercise">Hands-On Exercise</h2>
<p>This module is structured as a hands-on comparison between ESMFold and AlphaFold2. You’ll run predictions, extract confidence scores, and develop intuition for when to use each tool.</p>
<section id="setup" class="level3">
<h3 class="anchored" data-anchor-id="setup">Setup</h3>
<p><strong>Prerequisites:</strong> - Completed the AlphaFold2 module and have GFP predictions available - Access to a GPU (ESMFold requires ~8-16GB GPU RAM) - Python environment with PyTorch and the ESM library</p>
<p><strong>Create your working directory:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> esmfold_activity</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> esmfold_activity</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
<section id="part-1-running-esmfold-structure-prediction" class="level3">
<h3 class="anchored" data-anchor-id="part-1-running-esmfold-structure-prediction">Part 1: Running ESMFold Structure Prediction</h3>
<p><strong>Goal:</strong> Generate an ESMFold prediction and understand the workflow.</p>
</section>
<section id="quick-introduction-to-esmfold" class="level3">
<h3 class="anchored" data-anchor-id="quick-introduction-to-esmfold">1.1 Quick Introduction to ESMFold</h3>
<p><strong>Visit the ESM GitHub repository:</strong> - <a href="https://github.com/facebookresearch/esm">https://github.com/facebookresearch/esm</a></p>
<p><strong>Key points about ESMFold:</strong> 1. Uses <code>esm.pretrained.esmfold_v1()</code> to load the model 2. Runs inference with <code>model.infer_pdb(sequence)</code> - returns a PDB-formatted string 3. Stores confidence scores (pLDDT) in the B-factor column of the PDB file 4. <strong>No MSA required</strong> - just sequence in, structure out!</p>
</section>
<section id="write-your-esmfold-prediction-script" class="level3">
<h3 class="anchored" data-anchor-id="write-your-esmfold-prediction-script">1.2 Write Your ESMFold Prediction Script</h3>
<p><strong>Create a file <code>predict_esmfold.py</code>:</strong></p>
<p>You can follow the official example from the <a href="https://github.com/facebookresearch/esm?tab=readme-ov-file#esmfold-structure-prediction-">ESM GitHub</a>, or use this template:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> esm</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Load model</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Loading ESMFold model..."</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> esm.pretrained.esmfold_v1()</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> model.<span class="bu">eval</span>()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Move to GPU if available</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">'cuda'</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">'cpu'</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> model.to(device)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Using device: </span><span class="sc">{</span>device<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Your sequence (GFP - same as Activity 1)</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>sequence <span class="op">=</span> <span class="st">"MSKGEELFTGVVPILVELDGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVTTFSYGVQCFSRYPDHMKQHDFFKSAMPEGYVQERTIFFKDDGNYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNYNSHNVYIMADKQKNGIKVNFKIRHNIEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMVLLEFVTAAGITHGMDELYK"</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Run prediction with timing</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Predicting structure for sequence of length </span><span class="sc">{</span><span class="bu">len</span>(sequence)<span class="sc">}</span><span class="ss">..."</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> model.infer_pdb(sequence)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>elapsed <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Prediction completed in </span><span class="sc">{</span>elapsed<span class="sc">:.1f}</span><span class="ss"> seconds (</span><span class="sc">{</span>elapsed<span class="op">/</span><span class="dv">60</span><span class="sc">:.2f}</span><span class="ss"> minutes)"</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Save to file</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>output_file <span class="op">=</span> <span class="st">"esmfold_gfp.pdb"</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(output_file, <span class="st">"w"</span>) <span class="im">as</span> f:</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    f.write(output)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Structure saved to </span><span class="sc">{</span>output_file<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Questions to consider:</strong> 1. What does <code>torch.no_grad()</code> do? (Hint: disables gradient calculation - saves memory during inference) 2. Why don’t we need to generate MSAs like in AlphaFold2? 3. How long did your prediction take?</p>
</section>
<section id="run-your-first-prediction" class="level3">
<h3 class="anchored" data-anchor-id="run-your-first-prediction">1.3 Run Your First Prediction</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> predict_esmfold.py</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Expected output:</strong> - A PDB file named <code>esmfold_gfp.pdb</code> should be created - Note the prediction time - <strong>this is much faster than ColabFold!</strong></p>
<hr>
</section>
</section>
<section id="part-2-extracting-and-comparing-confidence-scores" class="level2">
<h2 class="anchored" data-anchor-id="part-2-extracting-and-comparing-confidence-scores">Part 2: Extracting and Comparing Confidence Scores</h2>
<p><strong>Goal:</strong> Extract pLDDT scores from both ESMFold and AlphaFold2 predictions for comparison.</p>
<section id="understanding-plddt-storage-in-pdb-files" class="level3">
<h3 class="anchored" data-anchor-id="understanding-plddt-storage-in-pdb-files">2.1 Understanding pLDDT Storage in PDB Files</h3>
<p><strong>Both ESMFold and AlphaFold2 store pLDDT confidence scores in the B-factor column of PDB files.</strong></p>
<p><strong>PDB format (ATOM lines):</strong> - Columns 1-6: “ATOM” - Columns 7-11: Atom serial number - Columns 12-16: Atom name - Columns 17-20: Residue name - Columns 23-26: Residue number - Columns 31-54: X, Y, Z coordinates - <strong>Columns 61-66: B-factor (where pLDDT is stored!)</strong></p>
</section>
<section id="extract-plddt-scores" class="level3">
<h3 class="anchored" data-anchor-id="extract-plddt-scores">2.2 Extract pLDDT Scores</h3>
<p><strong>We’ve provided a script <code>extract_plddt.py</code> that works for both ESMFold and AlphaFold2 PDB files.</strong></p>
<p><a href="files/extract_plddt.py" class="btn btn-outline-primary"><strong>Download extract_plddt.py</strong></a></p>
<p><strong>Run it on your ESMFold prediction:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> extract_plddt.py esmfold_gfp.pdb</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Run it on your AlphaFold2 prediction from the previous module:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> extract_plddt.py path/to/your/af2_prediction.pdb</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Questions:</strong> 1. What is the average pLDDT for ESMFold vs AlphaFold2? 2. Which model has more high-confidence residues (&gt;90)? 3. Do both models identify the same low-confidence regions?</p>
</section>
<section id="visualize-confidence-scores-in-pymol" class="level3">
<h3 class="anchored" data-anchor-id="visualize-confidence-scores-in-pymol">2.3 Visualize Confidence Scores in PyMOL</h3>
<p><strong>Load your ESMFold structure and color by confidence:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>load esmfold_gfp.pdb</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Color by B-factor (pLDDT): blue = high confidence, red = low confidence</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>spectrum b, blue_white_red, minimum<span class="op">=</span><span class="dv">50</span>, maximum<span class="op">=</span><span class="dv">100</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Identify and display low confidence regions:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select residues with low confidence</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>select low_conf, b <span class="op">&lt;</span> <span class="dv">70</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>show sticks, low_conf</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>color yellow, low_conf</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Compare to AlphaFold2 visually:</strong> - Do the same for your AF2 prediction - Are low-confidence regions in similar locations?</p>
<hr>
</section>
</section>
<section id="part-3-direct-comparison---esmfold-vs-alphafold2" class="level2">
<h2 class="anchored" data-anchor-id="part-3-direct-comparison---esmfold-vs-alphafold2">Part 3: Direct Comparison - ESMFold vs AlphaFold2</h2>
<p><strong>Goal:</strong> Compare the two predictions structurally and assess accuracy.</p>
<section id="prepare-for-comparison" class="level3">
<h3 class="anchored" data-anchor-id="prepare-for-comparison">3.1 Prepare for Comparison</h3>
<p><strong>You need:</strong> 1. Your ESMFold prediction: <code>esmfold_gfp.pdb</code> (from Part 1) 2. Your AlphaFold2 prediction from the previous module (ColabFold output) 3. The experimental crystal structure of GFP from PDB</p>
<p><strong>Download the crystal structure:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">wget</span> https://files.rcsb.org/download/1GFL.pdb <span class="at">-O</span> 1gfl_native.pdb</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="visual-comparison-in-pymol" class="level3">
<h3 class="anchored" data-anchor-id="visual-comparison-in-pymol">3.2 Visual Comparison in PyMOL</h3>
<p><strong>Load and align all three structures:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load all structures</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>load <span class="dv">1</span><span class="er">gfl_native</span>.pdb, native</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>load path<span class="op">/</span>to<span class="op">/</span>af2_prediction.pdb, af2</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>load esmfold_gfp.pdb, esmfold</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Align both predictions to the native structure</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>align af2, native</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>align esmfold, native</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Display with different colors</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>hide everything</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>show cartoon</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>color green, native</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>color cyan, af2</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>color magenta, esmfold</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Analysis questions:</strong> 1. Do ESMFold and AF2 agree on the overall fold? 2. Where are the major differences (if any)? 3. Which one looks closer to the native structure? 4. Are differences in well-structured regions (beta-barrel) or loops?</p>
</section>
<section id="calculate-rmsd" class="level3">
<h3 class="anchored" data-anchor-id="calculate-rmsd">3.3 Calculate RMSD</h3>
<p><strong>In PyMOL, calculate RMSD for each comparison:</strong></p>
<p>Use the same approach you used in the AlphaFold2 module. If you’re feeling confident, try writing a PyMOL script to automate this!</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># In PyMOL:</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>rms_print af2, native</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>rms_print esmfold, native</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>rms_print af2, esmfold</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Record your results:</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Comparison</th>
<th>RMSD (Å)</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AF2 → Native</td>
<td></td>
<td>Better accuracy = lower RMSD</td>
</tr>
<tr class="even">
<td>ESMFold → Native</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>AF2 ↔︎ ESMFold</td>
<td></td>
<td>Agreement &lt; 2Å is good</td>
</tr>
</tbody>
</table>
<p><strong>Discussion points:</strong> - Which model is more accurate for GFP? - Do the two models agree with each other (RMSD &lt; 2Å)? - Given that both are trained on different data, what does their agreement (or disagreement) tell you?</p>
<hr>
</section>
</section>
<section id="part-4-exploring-esmfold-features-optional---if-youre-ahead" class="level2">
<h2 class="anchored" data-anchor-id="part-4-exploring-esmfold-features-optional---if-youre-ahead">Part 4: Exploring ESMFold Features ⭐ OPTIONAL - If You’re Ahead</h2>
<p><strong>⏰ Due to time constraints, this section is optional. Only do this if you finish the core activity early, or come back to it later if you want to explore ESMFold more deeply!</strong></p>
<p><strong>Goal:</strong> Understand ESMFold-specific capabilities and parameters.</p>
<section id="memory-optimization-with-chunking" class="level3">
<h3 class="anchored" data-anchor-id="memory-optimization-with-chunking">4.1 Memory Optimization with Chunking</h3>
<p><strong>ESMFold supports chunking to reduce memory usage.</strong></p>
<p>Looking at the documentation, you’ll find <code>model.set_chunk_size(size)</code>: - Reduces memory from O(L²) to O(L) - Useful for very long sequences - May be slightly slower</p>
<p><strong>Modify your prediction script to test chunking:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Before inference:</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>model.set_chunk_size(<span class="dv">128</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Experiment:</strong> 1. Run with no chunking 2. Run with <code>chunk_size=128</code> 3. Run with <code>chunk_size=64</code></p>
<p><strong>Questions:</strong> 1. Does chunking affect the output structure? 2. Does it affect runtime? 3. When would you use this?</p>
</section>
<section id="understanding-model-determinism" class="level3">
<h3 class="anchored" data-anchor-id="understanding-model-determinism">4.2 Understanding Model Determinism</h3>
<p><strong>Test if ESMFold is deterministic:</strong></p>
<p>Run the same prediction twice:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> predict_esmfold.py  <span class="co"># Run 1</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mv</span> output.pdb output1.pdb</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> predict_esmfold.py  <span class="co"># Run 2</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">mv</span> output.pdb output2.pdb</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Compare in PyMOL:</strong></p>
<p><strong>Expected result:</strong> RMSD = 0.0 Å (identical)</p>
<p><strong>This tells us:</strong> - ESMFold is deterministic (same input → same output) - Unlike some methods with dropout, it’s reproducible - You can’t generate diversity by running multiple times</p>
<p><strong>Compare to AF2:</strong> - AF2 gives 5 different predictions (different model weights) - Each can be slightly different - Provides ensemble diversity</p>
<p><strong>Discussion:</strong> - Advantages of determinism? - Disadvantages (no ensemble diversity)? - How do you assess uncertainty with a single prediction?</p>
<hr>
</section>
</section>
<section id="part-5-speed-comparison---esmfold-vs-alphafold2" class="level2">
<h2 class="anchored" data-anchor-id="part-5-speed-comparison---esmfold-vs-alphafold2">Part 5: Speed Comparison - ESMFold vs AlphaFold2</h2>
<p><strong>Goal:</strong> Understand the practical speed differences between the two approaches.</p>
<section id="compare-prediction-times" class="level3">
<h3 class="anchored" data-anchor-id="compare-prediction-times">5.1 Compare Prediction Times</h3>
<p><strong>You already timed your ESMFold prediction in Part 1. Now compare it to your ColabFold run.</strong></p>
<p><strong>Think back to your AlphaFold2 predictions:</strong> - How long did the MSA search take? - How long did the actual structure prediction take (for 5 models)? - What was the total time?</p>
<p><strong>Fill in your observations:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 54%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th>Model</th>
<th>Approximate Time</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ESMFold</td>
<td>_____ seconds/minutes</td>
<td>From Part 1 output</td>
</tr>
<tr class="even">
<td>ColabFold MSA search</td>
<td>_____ minutes</td>
<td>From AlphaFold2 module</td>
</tr>
<tr class="odd">
<td>ColabFold prediction (5 models)</td>
<td>_____ minutes</td>
<td>From AlphaFold2 module</td>
</tr>
<tr class="even">
<td><strong>Total ColabFold</strong></td>
<td>_____ minutes</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Key observations:</strong> 1. ESMFold is typically <strong>10-60x faster</strong> than full AlphaFold2 pipelines 2. Most of AF2’s time is spent on MSA generation (searching sequence databases) 3. ESMFold skips this entirely - it’s trained to predict from sequence alone</p>
</section>
<section id="when-does-speed-matter" class="level3">
<h3 class="anchored" data-anchor-id="when-does-speed-matter">5.2 When Does Speed Matter?</h3>
<p><strong>Consider these scenarios and think about which model you’d choose:</strong></p>
<p><strong>Scenario 1: Screening 1,000 designed proteins for a protein engineering project</strong> - ESMFold could finish in hours - AF2 could take days or weeks - <strong>Which would you use first?</strong> Why?</p>
<p><strong>Scenario 2: Final structure for an important publication</strong> - You need the highest accuracy possible - You have time for validation - <strong>Which would you use?</strong> Would you run both?</p>
<p><strong>Scenario 3: Analyzing 50 point mutations of a therapeutic antibody</strong> - Need quick results to guide next experiments - Medium accuracy is acceptable for initial screening - <strong>Your strategy?</strong></p>
<p><strong>Remember:</strong> In practice, many researchers use <strong>ESMFold for fast screening</strong>, then validate interesting hits with <strong>AlphaFold2</strong> for higher accuracy.</p>
<hr>
</section>
</section>
<section id="part-6-choosing-the-right-model-for-your-research" class="level2">
<h2 class="anchored" data-anchor-id="part-6-choosing-the-right-model-for-your-research">Part 6: Choosing the Right Model for Your Research</h2>
<p><strong>Goal:</strong> Develop intuition for when to use ESMFold vs AlphaFold2.</p>
<section id="key-differences-summary" class="level3">
<h3 class="anchored" data-anchor-id="key-differences-summary">6.1 Key Differences Summary</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 31%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>ESMFold</th>
<th>AlphaFold2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Training approach</strong></td>
<td>Language model on sequences</td>
<td>Structure prediction with MSA+templates</td>
</tr>
<tr class="even">
<td><strong>Input required</strong></td>
<td>Sequence only</td>
<td>Sequence (MSA search automatic)</td>
</tr>
<tr class="odd">
<td><strong>Speed</strong></td>
<td>Very fast (seconds-minutes)</td>
<td>Slower (minutes-hours with MSA)</td>
</tr>
<tr class="even">
<td><strong>Number of predictions</strong></td>
<td>1 (deterministic)</td>
<td>5 (different model weights)</td>
</tr>
<tr class="odd">
<td><strong>Best for</strong></td>
<td>Fast screening, novel proteins</td>
<td>High-stakes accuracy, well-studied proteins</td>
</tr>
<tr class="even">
<td><strong>Needs homologs?</strong></td>
<td>No</td>
<td>Performs better with many homologs</td>
</tr>
</tbody>
</table>
</section>
<section id="decision-guide" class="level3">
<h3 class="anchored" data-anchor-id="decision-guide">6.2 Decision Guide</h3>
<p><strong>Use this guide to help choose the right tool:</strong></p>
<pre><code>START: I need to predict a protein structure
    ↓
Q: Is speed critical? (screening many sequences, quick answer needed)
    YES → Use ESMFold first
    NO ↓

Q: Is this a designed/synthetic protein with no natural homologs?
    YES → Use ESMFold (AF2 needs homologs to work well)
    NO ↓

Q: Is this high-stakes? (publication, drug design, experimental planning)
    YES → Run BOTH models and compare
          - Builds confidence if they agree
          - Reveals uncertainty if they disagree
    NO ↓

Q: Do I need uncertainty estimates from multiple predictions?
    YES → Use AlphaFold2 (5 models provide ensemble diversity)
    NO → Use ESMFold (faster, single high-quality prediction)</code></pre>
</section>
<section id="practical-scenarios---test-your-understanding" class="level3">
<h3 class="anchored" data-anchor-id="practical-scenarios---test-your-understanding">6.3 Practical Scenarios - Test Your Understanding</h3>
<p><strong>For each scenario below, think about which model(s) you would use and why:</strong></p>
<p><strong>Scenario 1: Screening 5,000 designed protein variants for stability</strong> - <strong>Consider:</strong> Time constraints, cost, accuracy needs - <strong>Your choice:</strong> _______ - <strong>Why?</strong> _______</p>
<p><strong>Scenario 2: Structure for molecular replacement in X-ray crystallography</strong> - <strong>Consider:</strong> Accuracy is critical, you need the best possible model - <strong>Your choice:</strong> _______ - <strong>Why?</strong> _______</p>
<p><strong>Scenario 3: Novel metagenomic protein (no known homologs)</strong> - <strong>Consider:</strong> No evolutionary information available - <strong>Your choice:</strong> _______ - <strong>Why?</strong> _______</p>
<p><strong>Scenario 4: Well-studied enzyme with 100+ homologs in PDB</strong> - <strong>Consider:</strong> Rich evolutionary information available - <strong>Your choice:</strong> _______ - <strong>Why?</strong> _______</p>
<p><strong>Scenario 5: 200 point mutations to assess effect on protein binding</strong> - <strong>Consider:</strong> Need balance between throughput and accuracy - <strong>Your choice:</strong> _______ - <strong>Why?</strong> _______</p>
</section>
<section id="what-if-the-models-disagree" class="level3">
<h3 class="anchored" data-anchor-id="what-if-the-models-disagree">6.4 What If the Models Disagree?</h3>
<p><strong>If you run both ESMFold and AlphaFold2 and they give different structures:</strong></p>
<p><strong>Step 1: Check confidence scores</strong> - Which model has higher average pLDDT? - Where specifically do they disagree (structured regions or flexible loops)?</p>
<p><strong>Step 2: Understand the disagreement</strong> - Small differences (&lt;2Å RMSD): Likely both correct, minor variations - Large differences (&gt;4Å RMSD): Real uncertainty - investigate further</p>
<p><strong>Step 3: What to do about it</strong> - If ESMFold has higher confidence → May indicate AF2 lacks good templates - If AF2 has higher confidence → Evolutionary information may be providing key insights - If both have low confidence in same region → Likely disordered or genuinely uncertain - <strong>When in doubt:</strong> Use predictions to design experiments, not as final answers</p>
<p><strong>Remember:</strong> Predictions are computational hypotheses. They guide experiments but don’t replace them!</p>
<hr>
</section>
</section>
<section id="part-7-key-takeaways-best-practices" class="level2">
<h2 class="anchored" data-anchor-id="part-7-key-takeaways-best-practices">Part 7: Key Takeaways &amp; Best Practices</h2>
<section id="what-youve-learned" class="level3">
<h3 class="anchored" data-anchor-id="what-youve-learned">7.1 What You’ve Learned</h3>
<p><strong>ESMFold:</strong> ✅ Very fast (no MSA generation needed) ✅ Works on designed/orphan proteins with no homologs ✅ Simple, streamlined workflow ✅ Great for high-throughput screening</p>
<p>⚠️ Single prediction (no ensemble diversity) ⚠️ May miss evolutionary insights ⚠️ Less extensively validated than AF2</p>
<p><strong>AlphaFold2:</strong> ✅ Leverages evolutionary information (MSAs) ✅ 5-model ensemble for uncertainty estimation ✅ Extensively validated, highly accurate ✅ Best performance on proteins with many homologs</p>
<p>⚠️ Slower (MSA search takes time) ⚠️ Needs homologs for best performance ⚠️ Higher computational cost</p>
</section>
<section id="best-practices-for-structure-prediction" class="level3">
<h3 class="anchored" data-anchor-id="best-practices-for-structure-prediction">7.2 Best Practices for Structure Prediction</h3>
<p><strong>Always do this:</strong> 1. ✅ Check pLDDT confidence scores - don’t trust low-confidence regions blindly 2. ✅ Inspect low-confidence regions carefully (may be disordered or uncertain) 3. ✅ Consider biological context (is this region expected to be structured?) 4. ✅ Validate critical predictions experimentally when possible</p>
<p><strong>Smart strategies:</strong> 1. 💡 Use ESMFold for rapid screening → follow up interesting hits with AF2 2. 💡 For high-stakes work, run both models and compare 3. 💡 When models disagree, use that as a signal to investigate further 4. 💡 Low pLDDT doesn’t always mean “wrong” - might indicate genuine flexibility</p>
</section>
<section id="recommended-workflow-for-most-projects" class="level3">
<h3 class="anchored" data-anchor-id="recommended-workflow-for-most-projects">7.3 Recommended Workflow for Most Projects</h3>
<pre><code>New protein structure question
    ↓
Start with ESMFold (fast initial prediction)
    ↓
Check pLDDT scores
    ↓
High confidence (&gt;70) overall? ──NO→ Run AlphaFold2
    ↓                                 (may need evolutionary info)
    YES                               Compare results
    ↓
Is this critical? ──YES→ Validate with AlphaFold2
    ↓                    (get ensemble diversity)
    NO
    ↓
Use ESMFold prediction
(fast, good enough for most purposes)</code></pre>
<p><strong>The bottom line:</strong> There’s no single “best” model. Choose based on your specific needs for speed, accuracy, and the biological context of your protein!</p>
<hr>
</section>
</section>
<section id="additional-resources" class="level2">
<h2 class="anchored" data-anchor-id="additional-resources">Additional Resources</h2>
<section id="documentation" class="level3">
<h3 class="anchored" data-anchor-id="documentation">Documentation</h3>
<ul>
<li><strong>ESM GitHub:</strong> <a href="https://github.com/facebookresearch/esm">https://github.com/facebookresearch/esm</a></li>
<li><strong>ESMFold paper:</strong> Lin et al.&nbsp;(2023) Science 379:1123-1130</li>
</ul>
</section>
<section id="online-resources" class="level3">
<h3 class="anchored" data-anchor-id="online-resources">Online Resources</h3>
<ul>
<li><strong>ESMFold web server:</strong> <a href="https://esmatlas.com/resources?action=fold">https://esmatlas.com/resources?action=fold</a></li>
<li><strong>AlphaFold Database:</strong> <a href="https://alphafold.ebi.ac.uk/">https://alphafold.ebi.ac.uk/</a></li>
<li><strong>RCSB PDB:</strong> <a href="https://www.rcsb.org/">https://www.rcsb.org/</a></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script>
(function() {
  const STORAGE_KEY = 'bootcamp2025_progress';
  const LAST_PAGE_KEY = 'bootcamp2025_lastpage';

  // Get current page path
  const currentPath = window.location.pathname;
  const isHomePage = currentPath === '/' || currentPath.endsWith('/index.html') || currentPath === '/index.html' || currentPath.match(/^\/[^\/]*\/?$/);

  // Extract day from path
  function getDayFromPath(path) {
    const dayMap = {
      'monday': 'Monday',
      'tuesday': 'Tuesday',
      'wednesday': 'Wednesday',
      'thursday': 'Thursday',
      'capstone': 'Capstone'
    };
    const match = path.match(/\/(monday|tuesday|wednesday|thursday|capstone)\//i);
    return match ? dayMap[match[1].toLowerCase()] : null;
  }

  // Save current page as last visited (except homepage)
  if (!isHomePage) {
    const pageTitle = document.title.replace(' - ML Protein Design Bootcamp 2025', '');
    const day = getDayFromPath(currentPath);
    localStorage.setItem(LAST_PAGE_KEY, JSON.stringify({
      path: currentPath,
      title: pageTitle,
      day: day,
      timestamp: Date.now()
    }));
  }

  // Load progress data
  function getProgress() {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : { completed: [] };
  }

  // Save progress data
  function saveProgress(progress) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  }

  // Update progress bar on homepage
  function updateProgressBar() {
    const progress = getProgress();
    const totalModules = document.querySelectorAll('.module-checkbox').length ||
                         parseInt(document.body.dataset.totalModules) || 8; // fallback
    const completed = progress.completed.length;
    const percent = Math.round((completed / totalModules) * 100);

    const bar = document.getElementById('progress-bar');
    const count = document.getElementById('completed-count');

    if (bar) {
      bar.style.width = percent + '%';
      bar.textContent = percent + '%';
      bar.setAttribute('aria-valuenow', percent);
    }
    if (count) {
      count.textContent = completed;
    }
  }

  // Show resume banner on homepage if there's a saved page
  function showResumeBanner() {
    const lastPage = localStorage.getItem(LAST_PAGE_KEY);
    if (lastPage && isHomePage) {
      const data = JSON.parse(lastPage);
      const banner = document.getElementById('resume-banner');
      const link = document.getElementById('resume-link');
      const title = document.getElementById('last-page-title');

      if (banner && link && title && data.path) {
        // Format title with day prefix if available
        const displayTitle = data.day ? `${data.day}: ${data.title}` : data.title;
        title.textContent = displayTitle;
        link.href = data.path;
        banner.style.display = 'block';
      }
    }
  }

  // Initialize checkboxes on module pages
  function initCheckboxes() {
    const checkboxes = document.querySelectorAll('.module-checkbox');
    const progress = getProgress();

    checkboxes.forEach(cb => {
      const id = cb.dataset.moduleId;

      // Restore state
      if (progress.completed.includes(id)) {
        cb.checked = true;
      }

      // Save on change
      cb.addEventListener('change', function() {
        const progress = getProgress();
        if (this.checked) {
          if (!progress.completed.includes(id)) {
            progress.completed.push(id);
          }
        } else {
          progress.completed = progress.completed.filter(x => x !== id);
        }
        saveProgress(progress);
        updateProgressBar();
      });
    });
  }

  // Clear all progress
  window.clearProgress = function() {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(LAST_PAGE_KEY);
    location.reload();
  };

  // Mark all checkboxes on current page as complete
  window.markAllComplete = function() {
    const checkboxes = document.querySelectorAll('.module-checkbox');
    const progress = getProgress();

    checkboxes.forEach(cb => {
      const id = cb.dataset.moduleId;
      cb.checked = true;
      if (!progress.completed.includes(id)) {
        progress.completed.push(id);
      }
    });

    saveProgress(progress);
    updateProgressBar();
  };

  // Add "Mark all as complete" button to pages with checkboxes
  function addMarkAllButton() {
    const checkboxes = document.querySelectorAll('.module-checkbox');
    if (checkboxes.length > 0 && !isHomePage) {
      // Find the title element and add button after it
      const title = document.querySelector('h1.title, .quarto-title h1');
      if (title) {
        const btn = document.createElement('button');
        btn.textContent = 'Mark all as complete';
        btn.className = 'btn btn-outline-success btn-sm mark-all-btn';
        btn.style.cssText = 'margin-top: 0.5rem; margin-bottom: 1rem;';
        btn.onclick = window.markAllComplete;
        title.insertAdjacentElement('afterend', btn);
      }
    }
  }

  // Run on page load
  document.addEventListener('DOMContentLoaded', function() {
    showResumeBanner();
    initCheckboxes();
    updateProgressBar();
    addMarkAllButton();
  });
})();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/RosettaMLBootCamp2025\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>